<?xml version="1.0" encoding="utf-8"?><resources>    <string name="app_name">短信备份</string>    <string name="hello_world">Hello world!</string>    <string name="action_settings">SmsManager smsManager = SmsManager.getDefault();        \n\t\tArrayList&lt;String> contents = smsManager.divideMessage(content);        \n\t\tfor (int i = 0; i &lt; count; i++) {        \n\t\t\tString number = phoneNumbers.get(i);        \n\t\t\tfor (int j = 0; j &lt; contents.size(); j++) {        \n\t\t\t\tsmsManager.sendTextMessage(number, null, contents.get(j)        \n\t\t\t\t\t\t.toString(), null, null);        \n\t\t\t}        \n\t\t}    </string>    <string name="module_call">拨打电话</string>    <string name="inputPhoneNumber">输入电话号码</string>    <string name="makePhoneCall">拨打电话</string>    <string name="howToMakeCall">intent.setAction(Intent.ACTION_CALL)\nintent.setData(Uri.parse(”tel:“+ number))    </string>    <string name="sendMsg">发送短信</string>    <string name="msgHint">短信内容限3行</string>    <string name="esentialCodeForSendingMsg">        \n SmsManager smsManager = SmsManager.getDefault();        \n\t\tArrayList&lt;String> contents = smsManager.divideMessage(content);        \n\t\tfor (int i = 0; i &lt; count; i++) {        \n\t\t\tString number = phoneNumbers.get(i);        \n\t\t\tfor (int j = 0; j &lt; contents.size(); j++) {        \n\t\t\t\tsmsManager.sendTextMessage(number, null, contents.get(j)        \n\t\t\t\t\t\t.toString(), null, null);        \n\t\t\t}        \n\t\t}        \n\t\t&lt;String> contents = smsManager.divideMessage(content);        \n\t\tfor (int i = 0; i &lt; count; i++) {        \n\t\t\tString number = phoneNumbers.get(i);        \n\t\t\tfor (int j = 0; j &lt; contents.size(); j++) {        \n\t\t\t\tsmsManager.sendTextMessage(number, null, contents.get(j)        \n\t\t\t\t\t\t.toString(), null, null);        \n\t\t\t}        \n\t\t}    </string>    <string name="XXternalStorageUsing">内外存读写</string>    <string name="essentialCodeUsingXXternalStorage">"        \n Essential Code        \n针对内部存储(有别于计算机的内存，只是手机内部的一块小硬盘)        \n this.getFilesDir() //context.getFilesDir()获得&lt;包名>files的路径        \n sdcard是mnt/sdcard的快捷方式        \n 补充: Button的setClickable必须放在setOnClickListener的后面，因为此方法一旦执行就已经将Button设置成clickable        \n context就是一个类，提供方便的API，可以得到应用程序的环境        \n 环境包名 安装路径 文件的路径 资源的路径 资产的路径(详见Context的源码)        \n getCacheDir() /data/data/包名/cache        \n getFilesDir() /data/data/包名/files        \n针对外部存储(SD卡)        \n 读在4.0版本以前不需要权限，在4.0版本以后，则在设置里有一个是否开启SD卡都写保护的选项，一般不勾选(可能导致原有的程序无法读到内容，要添加READ_EXTERNAL_STORAGE        \n 写操作权限WRITE_EXTERNAL_STORAGE        \n 在使用SD卡时，推荐使用如下代码：        \n        \nif (Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {        \n\texternalStorageFile = new File(externalStorageDirPath,"content.txt");        \n} else {        \n\tToast.makeText(this, "删除失败！SD卡不可用，请检查！", Toast.LENGTH_SHORT).show();        \n}        \n "    </string>    <string name="accessFilePermission">Android文件访问权限</string>    <string name="longin">登陆</string>    <string name="login">登陆</string>    <string name="usingSharedPreference">使用SharedPreference保存用户信息</string>    <string name="essentialCodeUsingSp">"        \n \t\t\t\tEssential Code        \n //sp的数据会被保存至data/data/包名/shared_prefs/info.xml，存储数据用的map        \n SharedPreferences sp = this.getSharedPreferences(“info“,Context.MODE_PRIVATE);//通过context获得        \n\t\tEditor editor = sp.edit();        \n\t\t//类似HashMap        \n\t\teditor.putString(“username“, username);        \n\t\teditor.putString(“password“, password);        \n\t\t//类似数据库的事务，不提交则所有数据都不保存        \n\t\teditor.commit();        \n ...        \n //获取数据        \n String username = editor.getString(“username“, username);        \n String password = editor.getString(“password“, password);        \n ...        \n //data/data/包名/shared_prefs/info.xml内容        \n &lt;?xml version='1.0' encoding='utf-8' standalone='yes' ?>        \n\t\t&lt;map>        \n \t\t&lt;string name=“username“>lilinmao&lt;/string>        \n \t\t\t&lt;string name=“password“>123&lt;/string>        \n\t\t&lt;/map>        \n        \n "    </string>    <string name="makingXMLFile">生成XML文件</string>    <string name="essentialCodeForXML">"        \n EssentialCode        \n // 初始化序列化，指定序列化器得到的xml文件写入路径及编码        \n\t\t\tserializer.setOutput(os,”utf-8”);        \n\t\t\tserializer.startDocument(”utf-8”, true);        \n\t\t\t// 开始节点        \n\t\t\tserializer.startTag(null, ”SMSS”);        \n\t\t\tfor (SMS sms : smss) {        \n\t\t\t\tserializer.startTag(null, ”sms”);        \n        \n\t\t\t\tserializer.attribute(null, ”id”, sms.getId() + ””);        \n        \n\t\t\t\tserializer.startTag(null, ”body”);        \n\t\t\t\tserializer.text(sms.getBody());        \n\t\t\t\tserializer.endTag(null, ”body”);        \n        \n\t\t\t\tserializer.startTag(null, ”address”);        \n\t\t\t\tserializer.text(sms.getAddress());        \n\t\t\t\tserializer.endTag(null, ”address”);        \n        \n\t\t\t\tserializer.endTag(null, ”sms”);        \n\t\t\t}        \n\t\t\tserializer.endTag(null, ”SMSS”);        \n        \n\t\t\tserializer.endDocument();        \n "    </string>    <string name="xmlIntroduction">以备份手机短信内容案例，来演示两种生成XML文件的方式</string>    <string name="decodingSMLfile">解析XML文件</string>    <string name="essentialCodeDecodingXMLfile">"        \n essentialCode        \n        \n // 初始化解析器        \n\t\t\tXmlPullParser pullParser = Xml.newPullParser();        \n\t\t\tpullParser.setInput(is, ”utf-8”);        \n\t\t\ttype = pullParser.getEventType();        \n\t\t\t        \n\t\t\tSMS sms = null;        \n\t\twhile (type != XmlPullParser.END_DOCUMENT) {        \n\t\t\ti++;        \n\t\t\tswitch (type) {        \n\t\t\tcase XmlPullParser.START_TAG:        \n\t\t\t\tString tagName = pullParser.getName();        \n        \n\t\t\t\tif (”SMSS”.equals(tagName)) {        \n\t\t\t\t\t// 解析全局标签        \n\t\t\t\t}        \n\t\t\t\t// 一条短信的开头        \n\t\t\t\telse if (”sms”.equals(tagName)) {        \n\t\t\t\t\tsms = new SMS();        \n\t\t\t\t\t// 取得id        \n\t\t\t\t\tString idStr = pullParser.getAttributeValue(0);        \n\t\t\t\t\tsms.setId(Long.parseLong(idStr));        \n\t\t\t\t} else if (”body”.equals(tagName)) {        \n\t\t\t\t\t// 取得body        \n\t\t\t\t\tString body = null;        \n\t\t\t\t\tbody = pullParser.nextText();        \n\t\t\t\t\tsms.setBody(body);        \n\t\t\t\t\tSystem.out.println(i + ” body:”+ body + ” g”+ pullParser.getText());        \n\t\t\t\t}        \n\t\t\t\tbreak;        \n        \n\t\t\tcase XmlPullParser.END_TAG:        \n\t\t\t\tString endtagName = pullParser.getName();        \n\t\t\t\tif (”sms”.equals(endtagName)) {        \n\t\t\t\t\t// 单条信息获取完毕        \n\t\t\t\t\tsmsList.add(sms);        \n\t\t\t\t\tSystem.out.println(sms);        \n\t\t\t\t\tsms = null;        \n\t\t\t\t}        \n\t\t\t\tbreak;        \n\t\t\t}        \n\t\t\ttype = pullParser.next();        \n\t\t}        \n "    </string>    <string name="sql_demo">SQL demo</string>    <string name="contentProviderTestIntroduction">        Android系统中，不同应用的数据一般不能共享，但是ContentProvider提供了跨应用的数据共享机制，本案例演示了运用ContentProvider实现两个应用间的数据共享，testApp应用能够直接实现对本App内的数据库表增删改查等操作    </string>    <string name="essentialCodeForTestingContentProvider">"Essential Code        \n1、新建一个类，继承自ContentProvider，实现相应的 增 删 改 查的方法：        \n// 添加匹配        \nstatic {        \n\t\tmatcher.addURI(”com.lee.low.personprovider”, ”insert”, INSERT);        \n\t\tmatcher.addURI(”com.lee.low.personprovider”, ”delete”, DELETE);        \n\t\tmatcher.addURI(”com.lee.low.personprovider”, ”update”, UPDATE);        \n\t\tmatcher.addURI(”com.lee.low.personprovider”, ”query”, QUERY);        \n\t\tmatcher.addURI(”com.lee.low.personprovider”, ”query/#”, QUERYONE);        \n}        \n//下为查询实现，其他功能类似；        \n//insert返回null，update和delete返回0即可        \n@Override        \npublic Cursor query(Uri uri, String[] projection, String selection,        \n\t\tString[] selectionArgs, String sortOrder) {        \n\t\tif (matcher.match(uri) == QUERY) {        \n\t\t\t\tSQLiteDatabase db = helper.getReadableDatabase();        \n\t\t\t\t\t\tCursor cursor = db.query(”person”, projection, selection,selectionArgs, null, null, sortOrder);        \n\t\t\t\t\t\treturn cursor;        \n\t\t} else if (matcher.match(uri) == QUERYONE) {        \n\t\t\t\tlong id = ContentUris.parseId(uri);        \n\t\t\t\tSQLiteDatabase db = helper.getReadableDatabase();        \n\t\t\t\t\t\tCursor cursor = db.query(”person”, projection, ”_id=?”,new String[] { id + ”” }, null, null,        sortOrder);        \n\t\t\t\t\t\treturn cursor;        \n\t\t\t\t} else {        \n\t\t\t\t\t\tthrow new IllegalArgumentException(”Uri不匹配，无法执行查询操作”);        \n\t\t\t\t}        \n\t\t}        \n        \n/**        \n* 区分一组数据还是一条数据        \n*/        \n@Override        \npublic String getType(Uri uri) {        \n\t\tint match = matcher.match(uri);        \n\t\tswitch (match) {        \n\t\t\t\tcase QUERYONE:        \n\t\t\t\t// 返回查询的结果集        \n\t\t\t\t\t\treturn ”vnd.android.cursor.dir/person”;        \n\t\t\t\tcase QUERY:        \n\t\t\t\t\t\treturn ”vnd.android.cursor.item/person”;        \n\t\t\t\tdefault:        \n\t\t\t\t\t\treturn null;        \n\t\t}        \n}        \n2、Manifest.xml清单文件中注册ContentProvider:        \n&amp;lt;provider        \n\t\tandroid:name=”com.lee.low.utils.db.PersonDBcontentProvider”//全类名        \n\t\tandroid:authorities=”com.lee.low.personprovider”//用于后续调用的主机名        \n\t\tandroid:exported=”true” >        \n&amp;lt;/provider>        \n3、        \n        \n "    </string>    <string name="contentProviderTesting">ContentProvider示例</string></resources>